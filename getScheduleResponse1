# Optimized `getScheduleResponse` Method

Here's the complete optimized method with comments that you can directly copy and paste into your codebase:

```java
/**
 * Converts ScheduleDataItem entities to ScheduleDataItems DTOs and populates
 * additional metadata through efficient batch processing.
 * 
 * @param responseList List of ScheduleDataItem entities from repository
 * @return List of enriched ScheduleDataItems DTOs
 */
private List<ScheduleDataItems> getScheduleResponse(List<ScheduleDataItem> responseList) {
    long startTime = System.currentTimeMillis();
    LOGGER.info("Starting ScheduleResponse processing for {} items", responseList.size());
    
    // Initialize collections
    List<ScheduleDataItems> scheduleDataItemsList = new ArrayList<>();
    ObjectMapper objectMapper = new ObjectMapper();
    List<Map<String, Object>> firmDataItemIdListForREP = new ArrayList<>();
    List<Map<String, Object>> firmDataItemIdListForREPSubmitted = new ArrayList<>();
    ScheduleDataItems scheduleDataItems;
    
    // Check feature toggle state once
    featureFlagReg9584 = FeatureToggle.isFeatureEnabled(Constants.REG9584);
    
    // STEP 1: Convert database entities to DTOs
    LOGGER.debug("Converting database entities to DTOs...");
    for (ScheduleDataItem scheduleDataItem : responseList) {
        scheduleDataItems = new ScheduleDataItems();
        if (scheduleDataItem != null) {
            // Base property mapping using existing helper
            scheduleDataItems = setScheduleDataItems(scheduleDataItem);
            
            // Date-related fields
            scheduleDataItems.setReportingPeriodStart(scheduleDataItem.getPeriodStartDate());
            scheduleDataItems.setReportingPeriodEnd(scheduleDataItem.getPeriodEndDate());
            scheduleDataItems.setSubmissionDueDate(scheduleDataItem.getSubmissionDueDate());
            
            // Determine data item type
            scheduleDataItems.setDataItemType(checkDataItemType(scheduleDataItem.getHandbookReference()));
            
            // Core identifiers
            scheduleDataItems.setScheduleDataItemId(scheduleDataItem.getScheduleId());
            scheduleDataItems.setHandbookReference(scheduleDataItem.getHandbookReference());
            scheduleDataItems.setCopyNumber(scheduleDataItem.getCopyNumber());
            scheduleDataItems.setSubsetStatus(scheduleDataItem.getSubsetStatus());
            scheduleDataItems.setCreatedDate(scheduleDataItem.getCreatedDdate());
            scheduleDataItems.setUpdateDate(scheduleDataItem.getUpdatedDate());
            
            // Optional fields with null checks
            if (scheduleDataItem.getRagName() != null) {
                scheduleDataItems.setRagName(scheduleDataItem.getRagName());
            }
            if (scheduleDataItem.getInformationCategoryName() != null) {
                scheduleDataItems.setInformationCategoryName(scheduleDataItem.getInformationCategoryName());
            }
            
            // Status fields
            scheduleDataItems.setCompletionStatus(scheduleDataItem.getCompletionStatus());
            scheduleDataItems.setDataItemName(scheduleDataItem.getDataItemName());
            scheduleDataItems.setStatus(scheduleDataItem.getStatus());
            
            // Submission details
            if (scheduleDataItem.getSubmittedBy() != null) {
                scheduleDataItems.setSubmittedBy(scheduleDataItem.getSubmittedBy());
            }
            if (scheduleDataItem.getSubmittedDate() != null) {
                scheduleDataItems.setSubmittedDate(CommonUtility.convertTimeStampToISODate(scheduleDataItem.getSubmittedDate()));
            }
            if (scheduleDataItem.getSubmitOnBehalf() != null) {
                scheduleDataItems.setSubmitOnBehalf(scheduleDataItem.getSubmitOnBehalf());
            }
            if (scheduleDataItem.getSubmissionMedthod() != null) {
                scheduleDataItems.setSubmissionMethod(scheduleDataItem.getSubmissionMedthod());
            }
            if (scheduleDataItem.getSubmissionReferenceNumber() != null) {
                scheduleDataItems.setSubmissionReferenceNumber(scheduleDataItem.getSubmissionReferenceNumber());
            }
            if (scheduleDataItem.getGroupSubmitterFrn() != null) {
                scheduleDataItems.setGroupSubmitterFrn(scheduleDataItem.getGroupSubmitterFrn());
            }
            
            // OPTIMIZATION: Set XBRL and A2C flags with data collection for batch processing 
            if (scheduleDataItem.getHandbookReference() != null) {
                // XBRL detection and flag setting
                if (uk.org.fca.gabriel.scs.lib.CommonUtility.checkIfXBRL(scheduleDataItems.getHandbookReference())) {
                    scheduleDataItems.setXbrl(true);
                } else {
                    scheduleDataItems.setXbrl(false);
                }
                
                // A2C detection and data collection
                if (scheduleDataItems.getHandbookReference().startsWith("REP026") && featureFlagReg9584) {
                    // Mark item as A2C
                    scheduleDataItems.setA2c(true);
                    
                    // Create data collection for batch processing
                    Map<String, Object> row = new HashMap<>();
                    row.put(Constants.FIRMDATAITEMID, scheduleDataItems.getFirmDataItemId());
                    row.put(Constants.HANDBOOKREFERENCE, scheduleDataItems.getHandbookReference());
                    row.put(Constants.REPORTINGENDDATE, scheduleDataItems.getReportingPeriodEnd());
                    
                    // Collect based on completion status
                    if (Constants.SUBMITTED.equalsIgnoreCase(scheduleDataItems.getCompletionStatus()) || 
                        Constants.COPY_CREATED.equalsIgnoreCase(scheduleDataItems.getCompletionStatus())) {
                        firmDataItemIdListForREPSubmitted.add(row);
                    } else if (!(Constants.DRAFT.equalsIgnoreCase(scheduleDataItems.getCompletionStatus()) || 
                                Constants.FAILED_VALIDATION.equalsIgnoreCase(scheduleDataItems.getCompletionStatus()) || 
                                Constants.NODATA.equalsIgnoreCase(scheduleDataItems.getCompletionStatus()))) {
                        firmDataItemIdListForREP.add(row);
                    }
                } else {
                    scheduleDataItems.setA2c(false);
                }
            }
            
            // Version information
            if (!StringUtils.isEmpty(scheduleDataItem.getVersion())) {
                scheduleDataItems.setVersion(scheduleDataItem.getVersion());
            }
        }
        scheduleDataItemsList.add(scheduleDataItems);
    }
    
    LOGGER.debug("Entity conversion completed. Processing metadata...");
    
    // STEP 2: Process A2C data (batch processing for A2C items)
    try {
        // OPTIMIZATION: Process A2C data efficiently 
        // Only make service calls if we have A2C data to process
        if (featureFlagReg9584) {
            Map<String, Map<String, Object>> dataItemDetailsForRep = new HashMap<>();
            Map<String, Map<String, Object>> submittedDataItemDetailsForRep = new HashMap<>();
            
            // Batch process REP data items
            if (!firmDataItemIdListForREP.isEmpty()) {
                LOGGER.debug("Fetching A2C details for {} regular REP items", firmDataItemIdListForREP.size());
                long repStart = System.currentTimeMillis();
                dataItemDetailsForRep = getDataItemDetails(objectMapper.writeValueAsString(firmDataItemIdListForREP));
                LOGGER.debug("A2C details fetched in {}ms", System.currentTimeMillis() - repStart);
            }
            
            // Batch process submitted REP data items
            if (!firmDataItemIdListForREPSubmitted.isEmpty()) {
                LOGGER.debug("Fetching A2C details for {} submitted REP items", firmDataItemIdListForREPSubmitted.size());
                long repSubmittedStart = System.currentTimeMillis();
                submittedDataItemDetailsForRep = getSubmittedDataItemDetails(objectMapper.writeValueAsString(firmDataItemIdListForREPSubmitted));
                LOGGER.debug("A2C submitted details fetched in {}ms", System.currentTimeMillis() - repSubmittedStart);
            }
            
            // Apply A2C error flags to items
            int a2cWarningsApplied = 0;
            for (ScheduleDataItems item : scheduleDataItemsList) {
                if (item.getA2c()) {
                    String id = String.valueOf(item.getFirmDataItemId());
                    
                    // Apply error flag for submitted items
                    if ((Constants.SUBMITTED.equalsIgnoreCase(item.getCompletionStatus()) || 
                         Constants.COPY_CREATED.equalsIgnoreCase(item.getCompletionStatus())) && 
                         submittedDataItemDetailsForRep != null && 
                         !submittedDataItemDetailsForRep.isEmpty() && 
                         submittedDataItemDetailsForRep.get(id) != null && 
                         !submittedDataItemDetailsForRep.get(id).get(Constants.VALIDATION_WARNINGS).equals(0)) {
                        
                        item.setA2cErrorFlag(Constants.WARNING);
                        a2cWarningsApplied++;
                    } 
                    // Apply error flag for other status items
                    else if (dataItemDetailsForRep != null && 
                             !dataItemDetailsForRep.isEmpty() && 
                             dataItemDetailsForRep.get(id) != null && 
                             !dataItemDetailsForRep.get(id).get(Constants.VALIDATION_WARNINGS).equals(0) && 
                             !(Constants.NODATA.equalsIgnoreCase(item.getCompletionStatus()) || 
                               Constants.FAILED_VALIDATION.equalsIgnoreCase(item.getCompletionStatus()) || 
                               Constants.DRAFT.equalsIgnoreCase(item.getCompletionStatus()))) {
                        
                        item.setA2cErrorFlag(Constants.WARNING);
                        a2cWarningsApplied++;
                    }
                }
            }
            LOGGER.debug("Applied A2C warnings to {} items", a2cWarningsApplied);
        }
    } catch (Exception e) {
        LOGGER.error("Exception occurred in A2C data processing: {}", e.getMessage(), e);
    }
    
    // STEP 3: Process XBRL items in batch
    // OPTIMIZATION: Call new method that processes all XBRL metadata in batch
    populateItemsMetadata(scheduleDataItemsList);
    
    long duration = System.currentTimeMillis() - startTime;
    LOGGER.info("Schedule response processing completed for {} items in {}ms", 
        scheduleDataItemsList.size(), duration);
    
    return scheduleDataItemsList;
}
```

And here's the complementary `populateItemsMetadata` method that should be added:

```java
/**
 * Efficiently populates metadata (filing indicators, error flags) for schedule data items.
 * This method replaces individual database calls in loops with efficient batch operations.
 * 
 * @param items The list of schedule data items to process
 */
private void populateItemsMetadata(List<ScheduleDataItems> items) {
    long startTime = System.currentTimeMillis();
    LOGGER.info("Starting metadata population for {} schedule data items", items.size());
    
    // 1. Extract all IDs in a single pass
    Set<Long> xbrlItemIds = new HashSet<>();
    Set<Long> errorFlagItemIds = new HashSet<>();
    int xbrlItemCount = 0;
    
    LOGGER.debug("Identifying XBRL items requiring metadata...");
    for (ScheduleDataItems item : items) {
        if (item.getXbrl()) {
            xbrlItemCount++;
            
            // Identify items needing filing indicators (submitted or copy created)
            if (Constants.SUBMITTED.equalsIgnoreCase(item.getCompletionStatus()) || 
                Constants.COPY_CREATED.equalsIgnoreCase(item.getCompletionStatus())) {
                xbrlItemIds.add(item.getFirmDataItemId());
            }
            
            // Identify items needing error flags (not NODATA or FAILED_VALIDATION)
            if (!(Constants.NODATA.equalsIgnoreCase(item.getCompletionStatus()) || 
                  Constants.FAILED_VALIDATION.equalsIgnoreCase(item.getCompletionStatus()))) {
                errorFlagItemIds.add(item.getFirmDataItemId());
            }
        }
    }
    
    LOGGER.debug("Found {} XBRL items: {} need filing indicators, {} need error flags",
        xbrlItemCount, xbrlItemIds.size(), errorFlagItemIds.size());
    
    // 2. Make batch service calls once (not repeatedly in loops)
    Map<String, String> filingIndicators = Collections.emptyMap();
    Map<String, String> errorFlags = Collections.emptyMap();
    
    // Get filing indicators in one batch (if needed)
    if (!xbrlItemIds.isEmpty()) {
        LOGGER.debug("Fetching filing indicators for {} items", xbrlItemIds.size());
        long filingStart = System.currentTimeMillis();
        filingIndicators = getFilingIndicators(new ArrayList<>(xbrlItemIds));
        LOGGER.debug("Filing indicators fetched in {}ms, received {} indicators", 
            System.currentTimeMillis() - filingStart, 
            filingIndicators != null ? filingIndicators.size() : 0);
    } else {
        LOGGER.debug("Skipping filing indicators - no items need them");
    }
    
    // Get error flags in one batch (if needed)
    if (!errorFlagItemIds.isEmpty()) {
        LOGGER.debug("Fetching error flags for {} items", errorFlagItemIds.size());
        long errorFlagStart = System.currentTimeMillis();
        errorFlags = getXbrlErrorFlag(new ArrayList<>(errorFlagItemIds));
        LOGGER.debug("Error flags fetched in {}ms, received {} flags", 
            System.currentTimeMillis() - errorFlagStart,
            errorFlags != null ? errorFlags.size() : 0);
    } else {
        LOGGER.debug("Skipping error flags - no items need them");
    }
    
    // 3. Apply metadata to items in a single pass
    LOGGER.debug("Applying metadata to XBRL items...");
    int filingIndicatorsApplied = 0;
    int errorFlagsApplied = 0;
    
    for (ScheduleDataItems item : items) {
        if (item.getXbrl()) {
            String itemId = String.valueOf(item.getFirmDataItemId());
            
            // Apply filing indicators if applicable
            if ((Constants.SUBMITTED.equalsIgnoreCase(item.getCompletionStatus()) || 
                Constants.COPY_CREATED.equalsIgnoreCase(item.getCompletionStatus())) && 
                filingIndicators != null && filingIndicators.containsKey(itemId)) {
                
                item.setFilingIndicators(filingIndicators.get(itemId));
                filingIndicatorsApplied++;
            }
            
            // Apply error flags if applicable
            if (!(Constants.NODATA.equalsIgnoreCase(item.getCompletionStatus()) || 
                Constants.FAILED_VALIDATION.equalsIgnoreCase(item.getCompletionStatus())) &&
                errorFlags != null && errorFlags.containsKey(itemId)) {
                
                item.setXbrlErrorFlag(errorFlags.get(itemId));
                errorFlagsApplied++;
            }
        }
    }
    
    // Log completion metrics
    long duration = System.currentTimeMillis() - startTime;
    LOGGER.info("Metadata population completed in {}ms: applied {} filing indicators and {} error flags",
        duration, filingIndicatorsApplied, errorFlagsApplied);
}
```

These methods can be directly copied and pasted into your `ScheduleDetailsServiceImpl` class. They maintain all the original functionality but process data more efficiently through batching.
